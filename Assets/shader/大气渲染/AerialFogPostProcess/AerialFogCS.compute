// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSFogMain

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> Result;

Texture2D<float4> _transmittanceLut;
SamplerState samplerLinearClamp;

int WIDTH;//128*32
int HEIGHT;//64

int VOXEL_W;//128
int VOXEL_H;//64
int VOXEL_D;//32

float _AerialPerspectiveDistance; 

float3 SunDir;
float3 eyePos;
float PlanetRadius;
float AtmosphereHeight;
float RayleighScatteringScalarHeight;
float MieScatteringScalarHeight;
float MieAnisotropy;
float OzoneLevelCenterHeight;
float OzoneLevelWidth;
float4 sunLuminance;

float4x4 _InvViewProjMatrix;
float4x4 _InvProjMatrix;
float4x4 _InvViewMatrix;

#define N_SAMPLE 50
#define PI  3.1415926

float3 VoxelToViewDir(int vx, int vy)
{
    float u = (vx + 0.5) / (float) VOXEL_W; // 0..1
    float v = (vy + 0.5) / (float) VOXEL_H; // 0..1
   
    float phi = u * 2.0 * PI;
    float theta = (v - 0.5) * PI;

    float3 dir;
    dir.x = cos(theta) * cos(phi);
    dir.y = sin(theta);
    dir.z = cos(theta) * sin(phi);
    return normalize(dir);
}

float RayIntersectSphere(float3 rayOrigin, float3 rayDir, float3 sphereCenter, float sphereRadius)
{
    rayDir = normalize(rayDir);
    float3 oc = rayOrigin - sphereCenter;
    float b = dot(oc, rayDir);
    float c = dot(oc, oc) - sphereRadius * sphereRadius;
    float discriminant = b * b - c;

    if (discriminant < 0)
        return -1.0;

    float sqrtD = sqrt(discriminant);
    float t1 = -b - sqrtD;
    float t2 = -b + sqrtD;

    
    if (t1 > 0)
        return t1;
    if (t2 > 0)
        return t2;
    return -1.0;
}

float3 RayleighCoefficient(float h)
{
    float3 sigma = float3(5.802, 13.558, 33.1) * 1e-6;
    float H_R = RayleighScatteringScalarHeight;
    float rho_h = exp(-(h / H_R));
    return sigma * rho_h;
}

float RayleighPhase(float cos_theta)
{
    return (3.0 / (16.0 * PI)) * (1.0 + cos_theta * cos_theta);
}

float3 MieCoefficient(float h)
{
    float3 sigma = (3.996 * 1e-6).xxx;
    float H_M = MieScatteringScalarHeight;
    float rho_h = exp(-(h / H_M));
    return sigma * rho_h;
}
        
float MiePhase(float cos_theta)
{
    float g = MieAnisotropy;
    float a = 3.0 / (8.0 * PI);
    float b = (1.0 - g * g) / (2.0 + g * g);
    float c = 1.0 + cos_theta * cos_theta;
    float d = pow(1.0 + g * g - 2 * g * cos_theta, 1.5);
    return a * b * (c / d);
}

float3 Scattering(float3 p, float3 inDir, float3 outDir)
{
    float cos_theta = dot(inDir, outDir);
    float h = length(p) - PlanetRadius;
    float3 rayleigh = RayleighCoefficient(h) * RayleighPhase(cos_theta);
 //
    float3 mie = MieCoefficient(h) * MiePhase(cos_theta);
 //
    return rayleigh + mie;
}

float3 MieAbsorption(float h)
{
    const float3 sigma = (4.4 * 1e-6).xxx;
    float H_M = MieScatteringScalarHeight;
    float rho_h = exp(-(h / H_M));
    return sigma * rho_h;
}

float3 OzoneAbsorption(float h)
{
    const float3 sigma_lambda = float3(0.650f, 1.881f, 0.085f) * 1e-6;
    float center = OzoneLevelCenterHeight;
    float width = OzoneLevelWidth;
    float rho = max(0, 1.0 - (abs(h - center) / width));
    return sigma_lambda * rho;
}

float2 GetTransmittanceLutUv(float bottomRadius, float topRadius, float mu, float r)
{
    float H = sqrt(topRadius * topRadius - bottomRadius * bottomRadius);
    float rho = sqrt(r * r - bottomRadius * bottomRadius);
    
    float discriminant = r * r * (mu * mu - 1.0) + topRadius * topRadius;
    float d = max(0.0, (-r * mu + sqrt(discriminant)));
    
    float d_min = topRadius - r;
    float d_max = rho + H;
    float x_mu = (d - d_min) / (d_max - d_min);
    float x_r = rho / H;
    
    return float2(x_mu, x_r);
}

float3 TransmittanceToAtmosphere(float3 p, float3 dir, Texture2D lut, SamplerState spl)
{
    float bottomRadius = PlanetRadius * 1e-3;
    float topRadius = PlanetRadius * 1e-3 + AtmosphereHeight * 1e-3;
    
    float3 upVector = normalize(p);
    float cos_theta = dot(upVector, dir);
    float r = length(p) * 1e-3;
    
    float2 uv = GetTransmittanceLutUv(bottomRadius, topRadius, cos_theta, r);
    return lut.SampleLevel(spl, uv, 0).rgb;
    
}

[numthreads(8,8,1)]
void CSFogMain(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= WIDTH || id.y >= HEIGHT)
        return;
    int slice = id.x / VOXEL_W;//Index
    int vx = id.x - slice * VOXEL_W;
    int vy = id.y;
    float3 viewDir = VoxelToViewDir(vx, vy);
    
    float slice01 = (slice + 0.5) / (float) (max(1, VOXEL_D - 1));
    float maxDis = slice01 * _AerialPerspectiveDistance;
    
    float3 inScat;
    float trans;   
    float3 color = float3(0, 0, 0);
    float3 opticalDepth = float3(0, 0, 0);
    
    float p2 = RayIntersectSphere(eyePos, viewDir, float3(0, 0, 0), PlanetRadius + AtmosphereHeight);
    
    float p2_1 = RayIntersectSphere(eyePos, viewDir, float3(0, 0, 0), PlanetRadius);
    
    if (p2 < 0)//out of the planet
    {
        Result[id.xy] = float4(color * viewDir, 1.0);
    }
    else
    {
        if (p2_1 > 0) p2 = min(p2, p2_1); //Looking down, intersect with planet first
        p2 = min(maxDis, p2);
        
        float ds = p2 / float(N_SAMPLE);
        float3 p = eyePos + (viewDir * ds) * 0.5;//the first sample point postion
        
        for (int i = 0; i < N_SAMPLE; i++)
        {
        
            float3 lightDir = SunDir;
            float h = length(p) - PlanetRadius;
       
            float3 extinction = RayleighCoefficient(h) + MieCoefficient(h) + OzoneAbsorption(h) + MieAbsorption(h);
            opticalDepth = opticalDepth + extinction * ds;
        
            float3 t1 = TransmittanceToAtmosphere(p, lightDir, _transmittanceLut, samplerLinearClamp);
            float3 s = Scattering(p, lightDir, viewDir);
        
            float3 t2 = exp(-opticalDepth);
        
            float3 inScattering = t1 * s * t2 * ds * sunLuminance.xyz;
        
            color = color + inScattering;
        
            p = p + viewDir * ds;
        }
        float3 p_start = eyePos;
        float3 p_end = eyePos + viewDir * p2;;
        if (viewDir.y < 0)
        {
            viewDir = -viewDir;
            
            float3 temp = p_start;
            p_start = p_end;
            p_end = temp;
        }
        float3 t_eye = TransmittanceToAtmosphere(eyePos, viewDir, _transmittanceLut, samplerLinearClamp);       
        float3 t_end = TransmittanceToAtmosphere(p_end, viewDir, _transmittanceLut, samplerLinearClamp);
        float3 t_ratio = t_eye / max(t_end, 1e-6);
        inScat = color;
        trans = dot(t_ratio, float3(1.0 / 3.0, 1.0 / 3.0, 1.0 / 3.0));
        
        Result[int2(id.x, id.y)] = float4(inScat, trans);
    }
    
    
}
